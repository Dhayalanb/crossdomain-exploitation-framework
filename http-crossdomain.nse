local http = require "http"
local nmap = require "nmap"
local shortport = require "shortport"
local table = require "table"
local stdnse = require "stdnse"
local json = require "json"

description = [[
1) Checks for overly permissive <code>/crossdomain.xml</code> files on a web server.
The script will alert if a wildcard entry is found.

If a <code>/crossdomain.xml</code> file is found that trusts certain domains, 
the script will generate a comma delimited list of the trusted domains so you 
can quickly check to see if any of them are available. 
]]

---
--@output
--80/tcp open  http
--| http-crossdomain: 
--|   POTENTIALLY VULNERABLE:
--|     Crossdomain.xml contains <allow-access-from domain="*">
--|       If the FQDN requires authentication and serves sensitive information,
--|       check out the references below for exploitation information.
--|   
--|   POTENTIALLY VULNERABLE:
--|     Crossdomain.xml whitelists domains that could potentially be available for purchase.
--|       If the FQDN requires authentication and serves sensitive information, 
--|       paste the following domains in the URL below to confirm availability.
--|   
--|       DOMAIN LOOKUP URL: https://www.dynadot.com/domain/bulk-search.html
--|   
--|       TRUSTED DOMAINS: domain.com,domain.au,domain.at,domain.be,domain.com.cn,domain.fr,domain.de,domain.com.hk,domain.in,domain1.com,domain2.com,domain3.com,domain4.com,domain5.com,domain6.com,mobile.domain.com,secure.domain.com
--|   
--|   REFERENCES:
--|     https://cwe.mitre.org/data/definitions/942.html 
--|_    http://sethsec.blogspot.com/2014/03/exploiting-misconfigured-crossdomainxml.html
---

---
--@usage
--nmap --script=http-crossdomain <target>
---

local liveLookup = stdnse.get_script_args({'http-crossdomain.liveLookup', 'liveLookup'}) or false

author = "Seth Art <sethsec@gmail.com>"
license = "Same as Nmap--See http://nmap.org/book/man-legal.html"
categories = {"default", "discovery", "safe"}

portrule = shortport.http

local function isempty(s)
  return s == nil or s == ''
end

local function checkDomain(line)
	--iana_tlds = http.get("data.iana.org", 80, "tlds-alpha-by-domain.txt")
        --print(iana_tlds)
        --print(line)

        -- Instantdomainsearch.com only supports the following domains. If the domain in the crossdomain.xml
	-- is one of the supported domains, we can use that lookup service.  If not, we need to fall back to
	-- just providing a list of domains

        insta_tlds={'com','net','org','co','info','biz','mobi','us','ca','co.uk','in','io','it','pt','me','tv'}

        -- This ipairs thing lets me pull one item from the insta_tlds list at a time.  
        for domainww, tld in ipairs(insta_tlds) do 
          --print (tld)
          -- This next match allows me see if the current value of the variable is at the end of the line
          if line:match("("..tld..")$") then
            --print(line)
            -- This allows me to match only the domain, getting rid of all subdomains. It pulls everything
	    -- between the last period and the tld 
            domain, tlds  = line:match("([^.]*).("..tld..")")
          else
            print(domain,tlds)
          end 
        end
        --local domain, tlds = line:match("([^.]*).(.*)")
        --print(domain,tlds)
        --print(tlds)
        local host = "instantdomainsearch.com"
        local port = { number = 443, protocol = "tcp" }
        local path = "/all/" .. domain .. "?/tlds=" .. tlds .. "&limit=1"
        --print(path)

        local response = http.get(host, port.number, path)
        if ( not(response) or response.status ~= 200 ) then
                return false, "Failed to retrieve results"
        end
        --print(response.body)
        local status, json_data = json.parse(response.body)
        if ( not(status) ) then
                return false, "Failed to parse JSON response"
        end
        isRegistered = json_data['isRegistered']
--        return true, json_data
        return isRegistered
end


---
-- Returns the table to be included in the nmap output
-- @param body   The HTTP RESPONSE body containing the contents of crossdomain.xml
---
local function parse_crossdomain(body)
output = {}
local domains = ""
local wildcard

  for line in body:gmatch("<allow%-access%-from(.-)%/>") do
    line = line:gsub("^%s*(.-)%s*$", "%1")
    if line:match("domain%=\"%*\"") then
      table.insert(output,"POTENTIALLY VULNERABLE:")
      table.insert(output,"  Crossdomain.xml contains <allow-access-from domain=\"*\">")
      table.insert(output,"    If the FQDN requires authentication and serves sensitive information,")
      table.insert(output,"    check out the references below for exploitation information.")
    table.insert(output,"")
    else
      line = line:match("domain%=\"(.-)\""):gsub("%*%.", "")
      if ( liveLookup ) then
        local registered, lookedUP  = checkDomain(line)
        if not registered then
          table.insert(output, "TRUSTED DOMAIN AVAILABLE FOR PURCHASE: " .. line)
        end
      else
        domains = domains .. line .. ","
      end
    end
  end
  domains = domains:gsub(",$", "")
  if not isempty(domains) then
    table.insert(output,"POTENTIALLY VULNERABLE:")
    table.insert(output,"  Crossdomain.xml whitelists domains that could potentially be available for purchase.")
    table.insert(output,"    If the FQDN requires authentication and serves sensitive information, ")
    table.insert(output,"    paste the following domains in the URL below to confirm availability.")
    table.insert(output,"")
    table.insert(output,"    DOMAIN LOOKUP URL: https://www.dynadot.com/domain/bulk-search.html")
    table.insert(output,"")
    table.insert(output,"    TRUSTED DOMAINS: " .. domains)
    table.insert(output,"") 
  end

  if not isempty(output) then
    table.insert(output,"") 
    table.insert(output,"REFERENCES:")
    table.insert(output,"  https://cwe.mitre.org/data/definitions/942.html ")
    table.insert(output,"  http://sethsec.blogspot.com/2014/03/exploiting-misconfigured-crossdomainxml.html")
  end 
  return output
end


---
-- Main 
---
action = function(host, port)
  local crossdomain 
  local answer = http.get(host, port, "/crossdomain.xml" )
  if answer.status ~= 200 then
    return nil
  end

  crossdomain = parse_crossdomain(answer.body)

  if crossdomain == 0 then
    return
  end

return crossdomain
end
